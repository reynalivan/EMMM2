---
trigger: model_decision
description: Meta Coding Standards Rule - When writing logic, refactoring code, or checking standard compliances.
---

# ðŸ§  Meta Coding Standards

> **Goal:** Maintain a distinct, modular, and AI-maintainable codebase by restricting complexity and enforcing clarity.

## 0. Naming & Immutability

- **Frontend (TS):** PascalCase (Components/Types), kebab-case (Files/Hooks), camelCase (Vars).
- **Backend (Rust):** snake_case (Files/Vars), PascalCase (Structs/Traits).
- **Immutability:** `const` default. Minimize `mut`. Strong typing with no `any`.

## 1. The 350-Line Limit (Modularity)

**Context:** Large files are hard to read and hard for AI to maintain context.

- **RULE:** No file should exceed **350 lines** of code.
- **ACTION:** If a file approaches this limit, refactor logic into helper functions, hooks (`useLogic`), or separate sub-modules.
- **RULE:** **1 Function = 1 Responsibility.**

## 2. Anti-Overengineering (YAGNI)

**Context:** Complexity kills startups.

- **RULE:** Do not build "Abstract Factories" for simple problems.
- **RULE:** Do not implement features "just in case".
- **RULE:** Use the simplest tool for the job.

## 3. Architecture Alignment (TRD)

**Context:** The codebase must reflect the documented architecture in `@/.docs/trd.md`.

- **Backend (Rust)**:
  - **Controllers (Commands)**: `src-tauri/src/commands/`. Only expose HTTP-like endpoints to React. No raw DB queries here.
  - **Business Logic (Services)**: `src-tauri/src/services/`. Orchestrates operations and enforces business rules. Decoupled from direct SQL where possible.
  - **Data Access Layer (Repositories)**: `src-tauri/src/database/`. All raw `sqlx` queries MUST reside here. Services call Repositories.
  - **Error Handling**: Use `thiserror` and `anyhow` as per TRD.
  - **Concurrency**: Use `tokio` for async I/O and `std::thread` for CPU-bound tasks (Deep Matcher).
  - **Code Quality (Clippy)**: Always respect and resolve warnings generated by `cargo clippy -- -D warnings`. Clippy is the ultimate truth for idiomatic Rust code.
- **Frontend (React)**:
  - **Frontend Alignment**: Keep UI logic completely decoupled from filesystem/database specifics. React only holds presentational state (`zustand`) and remote state caching (`TanStack Query`).
  - **Feature Slices**: Organize by feature in `src/features/` (Onboarding, Dashboard, etc.).

## 4. Control Flow (Fail Fast)

**Context:** Deep nesting hurts readability.

- **RULE:** Use **Guard Clauses** to return early.
- **FORBIDDEN:** Nested `if` statements deeper than 2 levels.
- **PATTERN:**
  ```typescript
  if (!user || !user.active) return;
  save();
  ```

## 5. SRP (One Thing Rule)

**Context:** "God Functions" are impossible to test.

- **RULE:** A function should do **one thing** only.
- **TEST:** Can you describe the function without using the word "and"?

## 6. Composition (The Lego Rule)

**Context:** Inheritance creates brittle chains.

- **RULE:** Prefer **Composition** over Inheritance.
- **PATTERN:** Use `hooks` (functional composition) instead of Class Inheritance.

## 7. No Circular Dependencies (Cycle-Free)

**Context:** A depends on B, and B depends on A.

- **RULE:** All dependencies must flow in one direction (Acyclic).
- **FORBIDDEN:** Circular imports between files or modules.

## 8. Anti-Hallucination (No AI Filler)

**Context:** AI assistants often fall into loops of generating useless adverbs ("seamlessly adequately gracefully flawlessly").

- **RULE:** **STRICTLY FORBIDDEN** to chain useless descriptive adverbs or adjectives in documentation, test cases, commit messages, or code comments.
- **ACTION:** Keep all communication strictly technical, observant, and concise. Never use "flawlessly" or "seamlessly" to describe code output.

## 9. Leveraging Active MCPs (Tool Usage)

**Context:** The AI agent uses various Model Context Protocol (MCP) servers to enforce and verify code standards.

- **Frontend & UI (`daisyui`, `shadcn-ui-server`)**: ALWAYS check documentation via the `mcp_daisyui_get_component` or `mcp_daisyui_list_components` before writing custom UI components. This ensures alignment with the project's DaisyUI v5 stack.
- **Deep Code Analysis & Safety (`narsil-mcp`)**:
  - Trace untyped data flow, test SQL injection safety, verify unreachable code (`mcp_narsil-mcp_find_dead_code`), and trace variable definitions (`mcp_narsil-mcp_get_data_flow`) when optimizing or writing secure Rust backend commands.
- **Documentation & Research (`context7`, `jina-mcp-server`)**: When dealing with external or updated APIs (React 19, Tauri v2), query documentation through `mcp_context7_resolve-library-id` or `jina-mcp-server` rather than guessing or hallucinating structures.
- **Complex Debugging (`sequential-thinking`)**: When root-causing memory leaks, concurrency issues, or architectural mismatch between frontend and backend, use the `sequential-thinking` MCP server to methodically build hypotheses and trace control flow.
- **E2E Validation (`playwright`, `puppeteer`)**: Leverage these servers to automate headless Chromium interactions during the `verify-quality` pipeline for deep integration tests on the UI layer.
